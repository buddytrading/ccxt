// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

//  ---------------------------------------------------------------------------
var yellow$1 = require("../abstract/yellow.js");
var _ = require("lodash");
var WebSocketClient = require("../base/ws/WebsocketClient.js").default;

//  ---------------------------------------------------------------------------
/**
 * @class yellow
 * @augments Exchange
 */
class yellow extends yellow$1 {
  describe() {
    return this.deepExtend(super.describe(), {
      id: "yellow",
      name: "Yellow",
      countries: ["JP", "MT"],
      rateLimit: 50,
      certified: false,
      pro: true,
      websockets: [],
      // new metainfo2 interface
      has: {
        CORS: undefined,
        spot: true,
        margin: true,
        option: true,
        cancelAllOrders: false,
        cancelOrder: false,
        createOrder: false,
        fetchBalance: false,
        fetchMyTrades: false,
        fetchOHLCV: true,
        fetchOpenOrders: false,
        fetchOrder: false,
        fetchOrders: false,
        sandbox: false,
        setLeverage: true,
        setMargin: false,
        setMarginMode: true,
        setPositionMode: true,
        watchOHLCV: true,
      },
      timeframes: {
        "1m": 1,
        "5m": 5,
        "15m": 15,
        "1h": 60,
        "12h": 720,
        "1d": 1440,
        "1M": 43800,
      },
      urls: {
        api: {
          ws: {
            spot: "wss://kayen.io/ws",
            margin: "wss://kayen.io/ws",
          },
        },
        www: "https://www.yellow.com",
        referral: {
          url: "https://accounts.yellow.com/en/register?ref=D7YA7CLY",
          discount: 0.1,
        },
        doc: ["https://developers.yellow.com/en"],
        api_management:
          "https://www.yellow.com/en/usercenter/settings/api-management",
        fees: "https://www.yellow.com/en/fee/schedule",
      },
      fees: {
        trading: {
          feeSide: "get",
          tierBased: false,
          percentage: true,
          taker: this.parseNumber("0.001"),
          maker: this.parseNumber("0.001"),
        },
        linear: {
          trading: {
            feeSide: "quote",
            tierBased: true,
            percentage: true,
            taker: this.parseNumber("0.000500"),
            maker: this.parseNumber("0.000200"),
            tiers: {
              taker: [
                [this.parseNumber("0"), this.parseNumber("0.000400")],
                [this.parseNumber("250"), this.parseNumber("0.000400")],
                [this.parseNumber("2500"), this.parseNumber("0.000350")],
                [this.parseNumber("7500"), this.parseNumber("0.000320")],
                [this.parseNumber("22500"), this.parseNumber("0.000300")],
                [this.parseNumber("50000"), this.parseNumber("0.000270")],
                [this.parseNumber("100000"), this.parseNumber("0.000250")],
                [this.parseNumber("200000"), this.parseNumber("0.000220")],
                [this.parseNumber("400000"), this.parseNumber("0.000200")],
                [this.parseNumber("750000"), this.parseNumber("0.000170")],
              ],
              maker: [
                [this.parseNumber("0"), this.parseNumber("0.000200")],
                [this.parseNumber("250"), this.parseNumber("0.000160")],
                [this.parseNumber("2500"), this.parseNumber("0.000140")],
                [this.parseNumber("7500"), this.parseNumber("0.000120")],
                [this.parseNumber("22500"), this.parseNumber("0.000100")],
                [this.parseNumber("50000"), this.parseNumber("0.000080")],
                [this.parseNumber("100000"), this.parseNumber("0.000060")],
                [this.parseNumber("200000"), this.parseNumber("0.000040")],
                [this.parseNumber("400000"), this.parseNumber("0.000020")],
                [this.parseNumber("750000"), this.parseNumber("0")],
              ],
            },
          },
        },
        inverse: {
          trading: {
            feeSide: "base",
            tierBased: true,
            percentage: true,
            taker: this.parseNumber("0.000500"),
            maker: this.parseNumber("0.000100"),
            tiers: {
              taker: [
                [this.parseNumber("0"), this.parseNumber("0.000500")],
                [this.parseNumber("250"), this.parseNumber("0.000450")],
                [this.parseNumber("2500"), this.parseNumber("0.000400")],
                [this.parseNumber("7500"), this.parseNumber("0.000300")],
                [this.parseNumber("22500"), this.parseNumber("0.000250")],
                [this.parseNumber("50000"), this.parseNumber("0.000240")],
                [this.parseNumber("100000"), this.parseNumber("0.000240")],
                [this.parseNumber("200000"), this.parseNumber("0.000240")],
                [this.parseNumber("400000"), this.parseNumber("0.000240")],
                [this.parseNumber("750000"), this.parseNumber("0.000240")],
              ],
              maker: [
                [this.parseNumber("0"), this.parseNumber("0.000100")],
                [this.parseNumber("250"), this.parseNumber("0.000080")],
                [this.parseNumber("2500"), this.parseNumber("0.000050")],
                [this.parseNumber("7500"), this.parseNumber("0.0000030")],
                [this.parseNumber("22500"), this.parseNumber("0")],
                [this.parseNumber("50000"), this.parseNumber("-0.000050")],
                [this.parseNumber("100000"), this.parseNumber("-0.000060")],
                [this.parseNumber("200000"), this.parseNumber("-0.000070")],
                [this.parseNumber("400000"), this.parseNumber("-0.000080")],
                [this.parseNumber("750000"), this.parseNumber("-0.000090")],
              ],
            },
          },
        },
        option: {},
      },
      commonCurrencies: {
        BCC: "BCC",
        YOYO: "YOYOW",
      },
      // exchange-specific options
      options: {
        sandboxMode: false,
        fetchMarkets: [
          "spot",
          "linear",
          "inverse", // allows CORS in browsers
          // 'option', // does not allow CORS, enable outside of the browser only
        ],
        fetchCurrencies: true,
        // 'fetchTradesMethod': 'publicGetAggTrades', // publicGetTrades, publicGetHistoricalTrades, eapiPublicGetTrades
        defaultTimeInForce: "GTC",
        defaultType: "spot",
        defaultSubType: undefined,
        hasAlreadyAuthenticatedSuccessfully: false,
        warnOnFetchOpenOrdersWithoutSymbol: true,
        // not an error
        // https://github.com/ccxt/ccxt/issues/11268
        // https://github.com/ccxt/ccxt/pull/11624
        // POST https://fapi.yellow.com/fapi/v1/marginType 400 Bad Request
        // binanceusdm
        throwMarginModeAlreadySet: false,
        fetchPositions: "positionRisk",
        recvWindow: 10 * 1000,
        timeDifference: 0,
        adjustForTimeDifference: false,
        newOrderRespType: {
          market: "FULL",
          limit: "FULL", // we change it from 'ACK' by default to 'FULL' (returns immediately if limit is not hit)
        },
        quoteOrderQty: true,
        broker: {
          spot: "x-R4BD3S82",
          margin: "x-R4BD3S82",
          future: "x-xcKtGhcu",
          delivery: "x-xcKtGhcu",
          swap: "x-xcKtGhcu",
          option: "x-xcKtGhcu",
        },
        accountsByType: {
          main: "MAIN",
          spot: "MAIN",
          funding: "FUNDING",
          margin: "MARGIN",
          cross: "MARGIN",
          future: "UMFUTURE",
          delivery: "CMFUTURE",
          linear: "UMFUTURE",
          swap: "UMFUTURE",
          inverse: "CMFUTURE",
          option: "OPTION",
        },
        accountsById: {
          MAIN: "spot",
          FUNDING: "funding",
          MARGIN: "margin",
          UMFUTURE: "linear",
          CMFUTURE: "inverse",
          OPTION: "option",
        },
        networks: {
          ERC20: "ETH",
          TRC20: "TRX",
          BEP2: "BNB",
          BEP20: "BSC",
          OMNI: "OMNI",
          EOS: "EOS",
          SPL: "SOL",
        },
        // keeping this object for backward-compatibility
        reverseNetworks: {
          "tronscan.org": "TRC20",
          "etherscan.io": "ERC20",
          "bscscan.com": "BSC",
          "explorer.yellow.org": "BEP2",
          "bithomp.com": "XRP",
          "bloks.io": "EOS",
          "stellar.expert": "XLM",
          "blockchair.com/bitcoin": "BTC",
          "blockchair.com/bitcoin-cash": "BCH",
          "blockchair.com/ecash": "XEC",
          "explorer.litecoin.net": "LTC",
          "explorer.avax.network": "AVAX",
          "solscan.io": "SOL",
          "polkadot.subscan.io": "DOT",
          "dashboard.internetcomputer.org": "ICP",
          "explorer.chiliz.com": "CHZ",
          "cardanoscan.io": "ADA",
          "mainnet.theoan.com": "AION",
          "algoexplorer.io": "ALGO",
          "explorer.ambrosus.com": "AMB",
          "viewblock.io/zilliqa": "ZIL",
          "viewblock.io/arweave": "AR",
          "explorer.ark.io": "ARK",
          "atomscan.com": "ATOM",
          "www.mintscan.io": "CTK",
          "explorer.bitcoindiamond.org": "BCD",
          "btgexplorer.com": "BTG",
          "bts.ai": "BTS",
          "explorer.celo.org": "CELO",
          "explorer.nervos.org": "CKB",
          "cerebro.cortexlabs.ai": "CTXC",
          "chainz.cryptoid.info": "VIA",
          "explorer.dcrdata.org": "DCR",
          "digiexplorer.info": "DGB",
          "dock.subscan.io": "DOCK",
          "dogechain.info": "DOGE",
          "explorer.elrond.com": "EGLD",
          "blockscout.com": "ETC",
          "explore-fetchhub.fetch.ai": "FET",
          "filfox.info": "FIL",
          "fio.bloks.io": "FIO",
          "explorer.firo.org": "FIRO",
          "neoscan.io": "NEO",
          "ftmscan.com": "FTM",
          "explorer.gochain.io": "GO",
          "block.gxb.io": "GXS",
          "hash-hash.info": "HBAR",
          "www.hiveblockexplorer.com": "HIVE",
          "explorer.helium.com": "HNT",
          "tracker.icon.foundation": "ICX",
          "www.iostabc.com": "IOST",
          "explorer.iota.org": "IOTA",
          "iotexscan.io": "IOTX",
          "irishub.iobscan.io": "IRIS",
          "kava.mintscan.io": "KAVA",
          "scope.klaytn.com": "KLAY",
          "kmdexplorer.io": "KMD",
          "kusama.subscan.io": "KSM",
          "explorer.lto.network": "LTO",
          "polygonscan.com": "POLYGON",
          "explorer.ont.io": "ONT",
          "minaexplorer.com": "MINA",
          "nanolooker.com": "NANO",
          "explorer.nebulas.io": "NAS",
          "explorer.nbs.plus": "NBS",
          "explorer.nebl.io": "NEBL",
          "nulscan.io": "NULS",
          "nxscan.com": "NXS",
          "explorer.harmony.one": "ONE",
          "explorer.poa.network": "POA",
          "qtum.info": "QTUM",
          "explorer.rsk.co": "RSK",
          "www.oasisscan.com": "ROSE",
          "ravencoin.network": "RVN",
          "sc.tokenview.com": "SC",
          "secretnodes.com": "SCRT",
          "explorer.skycoin.com": "SKY",
          "steemscan.com": "STEEM",
          "explorer.stacks.co": "STX",
          "www.thetascan.io": "THETA",
          "scan.tomochain.com": "TOMO",
          "explore.vechain.org": "VET",
          "explorer.vite.net": "VITE",
          "www.wanscan.org": "WAN",
          "wavesexplorer.com": "WAVES",
          "wax.eosx.io": "WAXP",
          "waltonchain.pro": "WTC",
          "chain.nem.ninja": "XEM",
          "verge-blockchain.info": "XVG",
          "explorer.yoyow.org": "YOYOW",
          "explorer.zcha.in": "ZEC",
          "explorer.zensystem.io": "ZEN",
        },
        networksById: {
          "tronscan.org": "TRC20",
          "etherscan.io": "ERC20",
          "bscscan.com": "BSC",
          "explorer.yellow.org": "BEP2",
          "bithomp.com": "XRP",
          "bloks.io": "EOS",
          "stellar.expert": "XLM",
          "blockchair.com/bitcoin": "BTC",
          "blockchair.com/bitcoin-cash": "BCH",
          "blockchair.com/ecash": "XEC",
          "explorer.litecoin.net": "LTC",
          "explorer.avax.network": "AVAX",
          "solscan.io": "SOL",
          "polkadot.subscan.io": "DOT",
          "dashboard.internetcomputer.org": "ICP",
          "explorer.chiliz.com": "CHZ",
          "cardanoscan.io": "ADA",
          "mainnet.theoan.com": "AION",
          "algoexplorer.io": "ALGO",
          "explorer.ambrosus.com": "AMB",
          "viewblock.io/zilliqa": "ZIL",
          "viewblock.io/arweave": "AR",
          "explorer.ark.io": "ARK",
          "atomscan.com": "ATOM",
          "www.mintscan.io": "CTK",
          "explorer.bitcoindiamond.org": "BCD",
          "btgexplorer.com": "BTG",
          "bts.ai": "BTS",
          "explorer.celo.org": "CELO",
          "explorer.nervos.org": "CKB",
          "cerebro.cortexlabs.ai": "CTXC",
          "chainz.cryptoid.info": "VIA",
          "explorer.dcrdata.org": "DCR",
          "digiexplorer.info": "DGB",
          "dock.subscan.io": "DOCK",
          "dogechain.info": "DOGE",
          "explorer.elrond.com": "EGLD",
          "blockscout.com": "ETC",
          "explore-fetchhub.fetch.ai": "FET",
          "filfox.info": "FIL",
          "fio.bloks.io": "FIO",
          "explorer.firo.org": "FIRO",
          "neoscan.io": "NEO",
          "ftmscan.com": "FTM",
          "explorer.gochain.io": "GO",
          "block.gxb.io": "GXS",
          "hash-hash.info": "HBAR",
          "www.hiveblockexplorer.com": "HIVE",
          "explorer.helium.com": "HNT",
          "tracker.icon.foundation": "ICX",
          "www.iostabc.com": "IOST",
          "explorer.iota.org": "IOTA",
          "iotexscan.io": "IOTX",
          "irishub.iobscan.io": "IRIS",
          "kava.mintscan.io": "KAVA",
          "scope.klaytn.com": "KLAY",
          "kmdexplorer.io": "KMD",
          "kusama.subscan.io": "KSM",
          "explorer.lto.network": "LTO",
          "polygonscan.com": "POLYGON",
          "explorer.ont.io": "ONT",
          "minaexplorer.com": "MINA",
          "nanolooker.com": "NANO",
          "explorer.nebulas.io": "NAS",
          "explorer.nbs.plus": "NBS",
          "explorer.nebl.io": "NEBL",
          "nulscan.io": "NULS",
          "nxscan.com": "NXS",
          "explorer.harmony.one": "ONE",
          "explorer.poa.network": "POA",
          "qtum.info": "QTUM",
          "explorer.rsk.co": "RSK",
          "www.oasisscan.com": "ROSE",
          "ravencoin.network": "RVN",
          "sc.tokenview.com": "SC",
          "secretnodes.com": "SCRT",
          "explorer.skycoin.com": "SKY",
          "steemscan.com": "STEEM",
          "explorer.stacks.co": "STX",
          "www.thetascan.io": "THETA",
          "scan.tomochain.com": "TOMO",
          "explore.vechain.org": "VET",
          "explorer.vite.net": "VITE",
          "www.wanscan.org": "WAN",
          "wavesexplorer.com": "WAVES",
          "wax.eosx.io": "WAXP",
          "waltonchain.pro": "WTC",
          "chain.nem.ninja": "XEM",
          "verge-blockchain.info": "XVG",
          "explorer.yoyow.org": "YOYOW",
          "explorer.zcha.in": "ZEC",
          "explorer.zensystem.io": "ZEN",
        },
        impliedNetworks: {
          ETH: { ERC20: "ETH" },
          TRX: { TRC20: "TRX" },
        },
        legalMoney: {
          MXN: true,
          UGX: true,
          SEK: true,
          CHF: true,
          VND: true,
          AED: true,
          DKK: true,
          KZT: true,
          HUF: true,
          PEN: true,
          PHP: true,
          USD: true,
          TRY: true,
          EUR: true,
          NGN: true,
          PLN: true,
          BRL: true,
          ZAR: true,
          KES: true,
          ARS: true,
          RUB: true,
          AUD: true,
          NOK: true,
          CZK: true,
          GBP: true,
          UAH: true,
          GHS: true,
          HKD: true,
          CAD: true,
          INR: true,
          JPY: true,
          NZD: true,
        },
        legalMoneyCurrenciesById: {
          BUSD: "USD",
        },
      },
    });
  }
  setSandboxMode(enable) {
    super.setSandboxMode(enable);
    this.options["sandboxMode"] = enable;
  }
  getExchangeWebsocket(id) {
    return _.find(this.websockets, { id });
  }
  async connectKayenWs(symbol, timeframe) {
    const id = `${symbol}_${timeframe}`;
    const exchangeWebsocket = this.getExchangeWebsocket(id);

    if (_.isEmpty(exchangeWebsocket)) {
      const client = new WebSocketClient();
      await client.connect("wss://kayen.io/ws");

      this.websockets.push({
        id,
        client,
      });

      return {
        id,
        client,
      };
    } else {
      return exchangeWebsocket;
    }
  }
  _convertBaseExchange(base) {
    return base === "btc" ? "wbtc" : base;
  }
  _convertQuoteExchange(quote) {
    return quote === "usdt" ? "usd" : quote;
  }
  _mapTimeframe(timeframe) {
    return this.timeframes[timeframe];
  }
  async watchOHLCV(symbol, timeframe = "1m", params = {}) {
    /**
     * @method
     * @name yellow#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */

    params["callerMethodName"] = "watchOHLCV";
    const id = `${symbol}_${timeframe}`;
    let exchangeWebsocket = this.getExchangeWebsocket(id);
    const [base, quote] = symbol.toLowerCase().split("/");
    const kline = `${this._convertBaseExchange(
      base
    )}${this._convertQuoteExchange(quote)}.kline-${timeframe}`;

    if (_.isEmpty(exchangeWebsocket)) {
      const client = new WebSocketClient();
      await client.connect("wss://kayen.io/ws");
      exchangeWebsocket = {
        id,
        client,
      };

      this.websockets.push(exchangeWebsocket);
      exchangeWebsocket.client.send(
        JSON.stringify([1, 1, "subscribe", ["public", [kline]]])
      );
    }

    const message = JSON.parse(await exchangeWebsocket.client.receive());
    if (message[1] === kline) {
      const candle = message[2];
      return [
        candle[0] * 1000, // convert from second to milisecond
        candle[1],
        candle[2],
        candle[3],
        candle[4],
        candle[5],
      ];
    }
    return [];
  }

  async watchOrders(symbol, params = {}) {
    /**
     * @method
     * @name yellow#watchOrders
     * @description watches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market the orders were made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string|undefined} [params.marginMode] 'cross' or 'isolated', for spot margin
     * @param {boolean} [params.portfolioMargin] set to true if you would like to watch portfolio margin account orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    return [];
  }
  async loadMarkets() {
    this.markets = {
      "BTC/USDT": {
        id: "BTC/USDT",
      },
      "ETH/USDT": {
        id: "ETH/USDT",
      },
    };
    return true;
  }

  async fetchOHLCV(
    symbol,
    timeframe = "1m",
    since = undefined,
    limit = undefined,
    params = {}
  ) {
    /**
     * @method
     * @name yellow#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.price] "mark" or "index" for mark price and index price candles
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    const client = new WebSocketClient();
    await client.connect("wss://kayen.io/ws");
    // Receive is asynchronous.
    const [base, quote] = symbol.toLowerCase().split("/");
    const kline = `${this._convertBaseExchange(
      base
    )}${this._convertQuoteExchange(quote)}`;
    if (_.isEmpty(since)) {
      since = Math.round(Date.now() / 1000) - 86400;
    }

    client.send(
      JSON.stringify([
        1,
        1,
        "klines",
        [
          this._mapTimeframe(timeframe),
          kline,
          since,
          Math.round(Date.now() / 1000),
        ],
      ])
    );
    // See if there are any more messages received.
    while (true) {
      const message = JSON.parse(await client.receive());
      if (message[0] === 2 && message[2] === "klines") {
        await client.disconnect();
        return _.takeRight(
          message[3].map((candle) => [
            candle[0] * 1000, // convert from second to milisecond
            candle[1],
            candle[2],
            candle[3],
            candle[4],
            candle[5],
          ]),
          limit
        );
      }
    }
  }

  async createOrder(
    symbol,
    type,
    side,
    amount,
    price = undefined,
    params = {}
  ) {
    /**
     * @method
     * @name yellow#createOrder
     * @description create a trade order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.reduceOnly] for swap and future reduceOnly is a string 'true' or 'false' that cant be sent with close position set to true or in hedge mode. For spot margin and option reduceOnly is a boolean.
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {boolean} [params.sor] *spot only* whether to use SOR (Smart Order Routing) or not, default is false
     * @param {boolean} [params.test] *spot only* whether to use the test endpoint or not, default is false
     * @param {float} [params.trailingPercent] the percent to trail away from the current market price
     * @param {float} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
     * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
     * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
     * @param {boolean} [params.portfolioMargin] set to true if you would like to create an order in a portfolio margin account
     * @param {string} [params.stopLossOrTakeProfit] 'stopLoss' or 'takeProfit', required for spot trailing orders
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    return null;
  }

  async cancelOrder(id, symbol = undefined, params = {}) {
    /**
     * @method
     * @name yellow#cancelOrder
     * @description cancels an open order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to cancel an order in a portfolio margin account
     * @param {boolean} [params.stop] set to true if you would like to cancel a portfolio margin account conditional order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if (symbol === undefined) {
      throw new Error(this.id + " cancelOrder() requires a symbol argument");
    }
    return null;
  }
  async cancelAllOrders(symbol = undefined, params = {}) {
    /**
     * @method
     * @name yellow#cancelAllOrders
     * @description cancel all open orders in a market
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {boolean} [params.portfolioMargin] set to true if you would like to cancel orders in a portfolio margin account
     * @param {boolean} [params.stop] set to true if you would like to cancel portfolio margin account conditional orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if (symbol === undefined) {
      throw new Error(
        this.id + " cancelAllOrders() requires a symbol argument"
      );
    }
    return null;
  }
  async fetchOpenOrders(
    symbol = undefined,
    since = undefined,
    limit = undefined,
    params = {}
  ) {
    /**
     * @method
     * @name yellow#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch open orders in the portfolio margin account
     * @param {boolean} [params.stop] set to true if you would like to fetch portfolio margin account conditional orders
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    return null;
  }
  async fetchOrders(
    symbol = undefined,
    since = undefined,
    limit = undefined,
    params = {}
  ) {
    /**
     * @method
     * @name yellow#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch orders in a portfolio margin account
     * @param {boolean} [params.stop] set to true if you would like to fetch portfolio margin account stop or conditional orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if (symbol === undefined) {
      throw new Error(this.id + " fetchOrders() requires a symbol argument");
    }
    return null;
  }
  async fetchMyTrades(
    symbol = undefined,
    since = undefined,
    limit = undefined,
    params = {}
  ) {
    /**
     * @method
     * @name yellow#fetchMyTrades
     * @description fetch all trades made by the user
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch trades for a portfolio margin account
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    return null;
  }
  async fetchBalance(params = {}) {
    /**
     * @method
     * @name yellow#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'future', 'delivery', 'savings', 'funding', or 'spot' or 'papi'
     * @param {string} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
     * @param {string[]|undefined} [params.symbols] unified market symbols, only used in isolated margin mode
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch the balance for a portfolio margin account
     * @param {string} [params.subType] 'linear' or 'inverse'
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    return null;
  }
  async fetchOrder(id, symbol = undefined, params = {}) {
    /**
     * @method
     * @name yellow#fetchOrder
     * @description fetches information on an order made by the user
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch an order in a portfolio margin account
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if (symbol === undefined) {
      throw new Error(this.id + " fetchOrder() requires a symbol argument");
    }
    return null;
  }
}

module.exports = yellow;
